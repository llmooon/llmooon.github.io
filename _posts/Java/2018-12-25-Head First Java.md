---
typora-copy-images-to: ..\assets
---

# 1. 간단하게 알아봅시다.

## 1-1. 자바는 어떤식으로 돌아갈까요?
![자바 동작방식](./../../../../assets/자바%20동작방식_jcwl8yycx.PNG)
1. 소스를 입력합니다.
2. javac(컴파일러 애플리케이션)을 실행시켜 java 파일을 실행시켜 컴파일 합니다. 컴파일 하고 난 후, 아무런 오류도 생기지 않으면 새로운 class(Byte Code) 파일이 생성됩니다.
3.
4. 자바 가상 머신(JVM)을 통해 class 파일을 실행한다. JVM은 바이트코드를 해당 플랫폼에서이해할 수 있는 형태로 해석하여 그 프로그램을 신행한다. JVM은 main 메소드 중괄호 안에 있는 것을 모두 실행한다. 모든 자바 애플리케이션에는 최소한 클래스가 하나 있어야 하며, 적어도 하나의 main 메소드가 있어야 합니다.
---
# 2. 클래스와 객체

## 2-1객체
- 인스턴스 : 객체
- 인스턴스 변수 : 객체의 상태(데이터)를 나타냄.
- 메소드 : 객체에서 할 수 있는 일을 나타냄.
- **클래스 VS 객체** : 클래스는 객체를 만들기 위한 청사진이다. 클래스로부터 만들어진 각 객체는 클래스의 인스턴스 변수용으로 쓰기 위한 변수를 가질 수 있다.

## 2-2 상속
![상속](/assets/상속.PNG)
- 하위 클래스는 상위 클래스의 메소드를 상속한다.
- **오버라이드** : 하위 클래스에서 메소드의 역활을 변경하거나 확장할 필요가 있을떄 상속받은 메소드를 새로 정의 하는것

 ## 2-3 객체 지향의 특징

### 2-3-1 추상화

- 공통의 속성이나 기능을 파악해 놓은 설계 기법

### 2-3-2 캡슐화

- 필드, 메소드를 하나로 묶고 실제 구현을 감추는 것. 외부 객체에서는 객체의 구조를 알 수 없고, 객체가 노출해서 제공하는 필드와 메소드만을 이용할 수 있다. (은닉화)

### 2-3-3 다형성

- 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질.
- 부모 클래스로부터 상속을 받은 속성에 대해, 자식 클래스에서 물려받은 속성을  재 정의 할 수 있다. (오버라이딩)

### 2-4-4 상속

- 상위 개념의 특징을 하위 개념이 물려 받는것.
- 상위의 필드와 메소드를 자식이 가진 속성으로 물려줘 코드 중복 문제 해결, 다형성, 유지 보수의 편리성의 이점이 있다.

---
 # 3. 네 변수를 알라

 ## 3-1변수
 ### 3-1-1. 원시 변수
 - 정수, 부울,부동 소수점과 같은 **기초적인 값** 이 들어간다.
 - 원시 변수에는 유형과 이름이 존재한다.

 ### 3-1-2. 객체 레퍼런스
 - 객체 레퍼런스에는 객체에 접근하는 방법을 알려주는 비트가 들어있다.
 - #### 객체 선언, 생성과 대입의 3단게
     ![객체선언,생성,대입3단계](/assets/객체선언,생성,대입3단계.PNG)
     - **1. 레퍼런스 변수 선언**: JVM에 레퍼런스 변수용 공간을 할당해달라는 요청을 한 다음 그 변수명을 myDog로 지정한다.
     - **2. 객체 생성** : JVM으로 하여금 힙에 새로운 Dog 객체를 위한 공간을 마련하도록 지시한다.
     - **3. 객체와 레퍼런스 연결** : 새로운 Dog 객체를 myDog라는 레퍼런스 변수에 대입한다.
---
   # 4. 객체의 행동
   ## 4-1인스턴스 변수와 지역 변수의 차이점
   - 인스턴스 변수 : 클래스 내에서 선언이 된다. 항상 초기에 기본값으로 설정 되어 있다.
   - 지역 변수 : 메소드 내에서 선언된다. 사용전 반드시 초기화를 해야한다.

---
# 6. 자바 API를 알아봅시다.

## 6-1 ArrayList VS 배열
|    | ArrayList  | 배열  |
|---|---|---|
| 크기  |  ArrayList에서는 ArrayList 유형의 객체만 만들면 된다. 크기가 동적으로 바뀐다. |  배열을 선언할때 유형과 크기가 정해진다. |
| 저장 객체  | ArrayList는 여러 가지 서로 다른 유형의 객체를 저장할 수 있다. 하지만 원시 유형을 저장할 수 없다. 객체만 저장 가능. 하지만 ArrayList에서 나오는 것은 모두 Object 객체이다.  | 선언한 타입의 유형의 객체만 삽입 가능  |

---

# 7. 상속과 다형성

## 7-1 상속
![상속](./../../../../assets/상속.PNG)
- 상위 클래스에 공통적인 부분(추상적인)을, 하위 클래스에 더 구체적인 부분들을 정의한다. 하위 클래스는 상위 클래스를 **확장(extend)** 한다.

### 7-2 오버라이드
-  하위 클래스에서 메소드의 역활을 변경하거나 확장할 필요가 있을 때 상속받은 메소드를 새로 정의하는 것.

###  7-3 상속을 할 수 없는 경우
  - private으로 선언한 인스턴스 변수와 메소드는 상속하지 않는다.
  - inner 클래스는 상속을 할 수 없다.
  - final 클래스는 상속 계층에서 맨 아래에 있는 클래스가 되어, 절대 확장할 수 없다.
  - 생성자가 모두 private인 경우, 확장을 할 수 없다.
### 7-4 상속을 사용해야 할 경우
  - 어떤 클래스가 다른 클래스(상위 클래스)를 더 구체화한 형식이라면 상속을 활용한다.('하위 클래스는 상위 클래스이다'의 관계여야 한다.)
  - 일반적인 형식에 속하는 여러 클래스에서 공유해야 하는 어떤 행동이 있다면 상속을 활용한다.
  - 이 두 가지 규칙에 위배된다면 어떤 코드를 다른 클래스에서 재사용할 수 있다는 이유만으로 상속을 사용하면 안된다.
### 7-5 상속의 장점
  - 코드의 재사용성
  - 일련의 클래스를 위한 공통적인 규약을 정의합니다.

    - 상속을 통해 연관된 일련의 클래스에 대해 공통적인 규약을 정의할 수 있다.
  - **다형성**
    - 일련의 클래스에 대한 상위클래스를 만들면 그 상위 클래스 형식이 들어갈 수 있는 모든 자리에 해당 상위클래스와 임의 하위 클래스에 속하는 객체를 마음대로 사용할 수 있다.

    - ##### Animal animal = new Dog();

    - 다형성을 사용하면 레퍼런스 유형을 실제 객체의 유형의 상위 클래스 유형으로 지정할 수 있다.

    - 인자와 리턴 유형에 대해서도 다형성을 적용 할 수 있다.

    - 다형성을 활용하면 새로운 하위 클래스 형식을 프로그램에 추가되더라고 코드를 굳이 바꿀 필요가 없다.

###  7-6 유형 안정성

- 어떤 객체 유형에 대해 요구해야 할 것을 엉뚱한 객체에 요구하는 일이 없도록 보장해준다.![](./../../../../assets/javatypesafy.PNG)

  ```java
  Object o = new Dog();
  o.bark(); //안됩니다.
  ```

  - Object로 선언한 레퍼런스 변수 o는 Object를 참조하고 있다고 생각하여 Object클래스에서 선언한 메소드만 호출할 수 있다.
  - 컴파일러에서 어떤 메소드를 호출할 수 있는지 결정할 때는 실제 객체 유형이 아닌 레퍼런스 유형 기준으로 결정된다.



# 8. 인터페이스를 이용한 설계





## 8-1. 인터페이스 VS 추상 메서드

### 8-1-1 공통점

- 인스턴스를 생성할 수 없고, 구현 내용이 없으며, 자식 클래스가 메서드의 구체적인 동작을 구현하도록 책임을 위임한다.

### 8-1-2 추상 클래스(<=> 구상 클래스(concrete class))

 - 객체를 생성하기 위함이 아니며, **상속을 위한 부모 클래스로 활용하기 위해 사용**

 - 추상 클래스를  상속 받아 기능을 이용하고 확장한다.

 - 인스턴스는 만들 수 없지만, 추상 유형을 레퍼런스로 사용할 순 있다.

 - 추상 클래스에 추상 메소드가 아닌 메소드를 집어 넣는 것은 가능하다.

 - #### 추상 메서드

    - 반드시 오버라이드 해야하는 메소드
    - 추상 메서드를 만들 때는 반드시 클래스도 추상 클래스, 인터페이스로 만들어야 함.

### 8-1-3 인터페이스

- 다중 상속의 모호함으로 인하여 인터페이스 사용
- 함수의 껍데기만 있으며, 그 함수의 구현을 강제함으로써 구현 객체의 같은 동작을 보장한다.
- 해당 인터페이스를 구현한 객체들에 대한 동일한 동작을 약속하기 위해 존재.



## 8.2 Object

- 명시적으로 다른 클래스를 확장하지 않은 클래스는 자동으로 Object를 확장한 클래스로 정의된다.
- 구성 메소드
  - equals() : 객체를 참조하고 있는 reference 변수가 같은지 확인.
  - getClass() : 어떤 클래스의 인스턴스인지 알 수 있도록 객체의 클래스 리턴.
  - hashCode() : 객체를 해시테이블에 집어넣는데 필요한 객체의 해시코드.
  - toString()
- 쓰임
  - 임의 클래스에 대해 어떤 작업을 하는 메소드를 만들 때 다형적 유형으로 사용하는 경우
  - 자바에 들어있는 모든 객체에서 필요한 진짜 메소드 코드를 제공하는 경우

