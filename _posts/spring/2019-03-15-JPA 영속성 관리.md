---
layout: post
comments: true
categories: Spring JPA
tag : Spring JpA
---

# JPA 영속성 관리

## 0. 영속성 (persistence)

- 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성
- 영속성을 갖지 않는 데이터는 단지 메모리에만 존재하기 때문에 프로그램을 종료하면 모두 잃어 버리게 된다. 때문에 파일 시스템, 관게형 데이터베이스 혹은 객체 데이터베이스 등을 활용하여 데이터를 영구하게 저장하여 영속성을 부여한다.
- **Persistence Layer**
  - 프로그램의 아케텍처에서, 데이터에 영속성을 부여해주는 계층을 말한다.
  - JDBC를 이용하여 직접 구현할 수 있지만 Persistence framework를 이용한 개발이 많이 이루어진다.
  - **Persistence framework**
    - JDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업만으로 데이터베이스와 연동되는 시스템을 빠르게 개발 할 수 있으며 안정적인 구동을 보장한다.
    - SQL Mapper 와 ORM으로 나눌 수 있다.

## 1. 영속성 컨텍스트 개념

- **영속성 컨텍스트 (Persistence Context)**
  - 엔티티를 영구 저장하는 환경
  - 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.

## 2. 엔티티의 생명주기

![](./../../assets/spring/jpa_persistance.PNG)

- 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속(merged) : 영속성 컨텍스트에 저장된 상태
- 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 (removed) : 삭제된 상태



### 3. 비영속

- 순수한 객체이며, 아직 영속성 컨텍스트와 연관이 없는 객체이다.

### 4. 영속

- Entity Manger를 통하여 엔티티를 영속성 컨텍스트에 저장했다.
- 영속성 컨텍스트가 관리하는 엔티티를 영속 상태라 한다.
- ORM을 사용하여 조회한 엔티티도 영속성 컨텍스트가 관리하는 영속 상태이다.

### 5. 준영속

- 영속성 컨텍스트과 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않으면 준영속 상태가 된다.
- session.close(), session.clear()를 통하여 준영속 상태로 만들 수 있다.

### 6. 삭제

- 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.



## 3. 영속성 컨텍스트의 특징

- JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영한다. 이 과정을 flush라 한다.
- 플러쉬는 영속성 컨텍스트의 변경 내용을 데이터베이스에 **동기화**하는 작업인데 이때 등록, 수정, 삭제한 엔티티를 데이터베이스에 반영한다. 

#### 영속성 컨텍스트가 엔티티를 관리하면 좋은 장점

- 1차 캐시, 동일성 보장, 트랜잭션, 변경 감지, 지연 로딩



## 4. 영속성 컨텍스트 사용 예시

#### 1. Entity 저장

   ```java
   // Controller 
   @PostMapping("") public ResponseEntity<String> saveMember(@RequestBody Member member) { 
       // 1. 파라미터로 받은 member 엔티티는 아직 영속화 되지 않은 상태 
       memberService.saveMember(member);
       return new ResponseEntity<>(Const.UPDATE_SUCCESS, HttpStatus.OK); 
   } 
   
   // Service 
   // 서비스 최상단에는 @Transactional이 선언되어 있어, begin()과 commit()으로 감싸져 있음
   @Override public void saveMember(Member member) { 
       // transaction.begin() 
       // 2 .영속상태 이전의 member 엔티티를 Repository에 전달
       memberRepository.saveMember(member); 
       // transaction.commit() 
       // 4. 트랜잭션이 커밋되며, Repository에서 영속화된 member 엔티티가 flush() 과정을 통해서 DB에 반영
       //?? 커밋하는 순간 데이터베이스에 Insert SQL을 보낸다.
   } 
       
   // Repository 
   @Override public void saveMember(Member member) { 
       // sessionFactory에서 session을 가져옴.
       Session session = sessionFactory.getCurrentSession(); 
       // 3. session.save(member) 과정을 통해서 member 엔티티는 영속화 되었고, 1차 캐시에 엔티티가 등록되며 쓰기지연 SQL 저장소에 저장 쿼리가 등록.
       session.save(member); 
   } 
   ```

   ![](./../../assets/spring/jpa_save.JPG)

![](./../../assets/spring/jpa_commit.JPG)

2. 



---

<참고>

https://gmlwjd9405.github.io/2018/12/25/difference-jdbc-jpa-mybatis.html  : 영속성 부분 참고

https://doublesprogramming.tistory.com/259

http://wonwoo.ml/index.php/post/997

https://wckhg89.tistory.com/10 : 영속성 컨텍스트, 생명주기, 영속 상태 및 DB 저장 과정 참고

https://lng1982.tistory.com/273

https://www.slideshare.net/zipkyh/ksug2015-jpa3-jpa : JPA 내부 구조 참고